@database "The GEM application support library"
@author   "Draco (draco@atari.org)"
@subject  Documentation/Manual
@$VER: gemma.stg (@:"__DATE__")
@options "-s +i +zz"

@node "Main"
@title "The GEM application support library"
@line 1 70 0

@{B}          GEMMA, the GEM application support library@{b}

@line 1 70 0

        I.   Installation

        II.  Function description

             1. Static library interface
             2. Application control functions
             3. Resource file related functions
             4. Environment functions
             5. Windowed dialog management
             6. External event handlers
             7. Alert functions
             8. Process management
             9. AV protocol support
            10. Invoking standard applications
            11. Other support

        III. Library functions listed by opcode

        VI.  CHANGES

@line 1 70 0

@endnode

@node "Installation"
Installation
@line 1 70 0

This is my GEM application support library. It mostly consists of 
functions I have written while developing bigger or smaller 
programs. Since I am lazy and really dislike writing the same code 
sequences again and again, I've decided to include all this in a 
library. And here it is.

The library upto version 1.04 was written entirely in assembler and 
was intended as a support for assembler programs. But it will 
probably work for other languages too, particularly for the C 
language. Now, since version 1.06 the library development continues 
in C - however, in turn, this does not mean that it cannot be used 
with programs written in other languages, including assembler.

The backside of the conversion done is, that MagiC users will 
probably not be able to use the compiled binary directly. This is 
because the gcc only produces binaries in the extended executable 
format, and SLBs in this format will probably not be accepted by 
MagiC.

The library is (obviously) multitasking safe and memory protection 
clean.

@{B}How to install@{b}

Unless otherwise specified in the documentation of a program which 
uses the library, the best choice is to put the gemma.slb into a 
folder where other such libs live. On my system this is 
/usr/local/lib/slb/ (i.e. u:/usr/local/lib) but you can obviously 
choose another location as well.

The folder must be pointed to by the $SLBPATH environment variable. 
You define this by adding a line like:

setenv SLBPATH u:/the/path/where/you/keep/libs

to your mint.cnf file. Notice that the FreeMiNT kernel requires it 
to be a single pathname, unlike $PATH, which can be a string made 
of subsequent pathnames of folders to search by.

If you already have an older version of the gemma.slb in that 
folder, you will probably have to replace it with newer one. If the 
folder is on a filesystem, which supports 'x-bits' (e.g. minix or 
ext2), you also have to set the x flags for each SLB file there or 
the system won't load them otherwise.

If you have programs which use the gemma.slb, you should also 
install the SMS server, which is a separate program used by the 
library for more functionality, when present. The server is 
available on the web under the following addresses:

http://draco.atari.org
http://piwo.bl.pg.gda.pl/~draco/falcon.html
http://wh58-508.st.uni-magdeburg.de/~draco/atari.html

Also installing the Assemsoft's StringServer is recommended. The 
StringServer can be downloaded at http://assemsoft.atari.org.

If you don't have StringServer installed, it is advised to define 
the following environment variables (all, or at least the first 
one):

GEMWWW=[here the full path to your WWW browser]
GEMFTP=[the full path to your FTP client]
GEMMAIL=[the full path to the mailer program]
GEMTELNET=[the full path to the telnet program]
GEMNEWS=[the full path to the news reader]
GEMGOPHER=[the full path to the gopher client]

If you don't have some of programs mentioned above, don't worry, 
just don't define the variable.

Have fun,
draco@atari.org

Warszawa, December 2000

@line 1 70 0

@endnode

@node "Invoking standard applications"
Invoking standard applications
@line 1 70 0

Almost every system (well, most of them) has several daily programs 
of similar or even the same type: a text editor, a text viewer, a 
CLI, a web browser et cetera. For a developer working in a 
multitasking environment it is extremely handy to have a 
standardized way of invoking such useful applications from within a 
program instead of being forced to code everything from scratch 
each time one needs a viewer.

There is much of this functionality in the desktop's AV protocol, 
which e.g. supplies the way of invoking a viewer for any data type 
known to the shell application (desktop), see the chapter entitled 
AV protocol support somewhere within this document. However, not 
everything can be done this way and thus the library provides 
methonds to access other applications as well, just to save your 
efforts.

@{B}long open_url(char *url)@{b}

Opcode:       40
Function:     execute an appropriate network client handing the 
              parameter off to it. The `url' must be a NULL 
              terminated string formatted in the normal form of the 
              Universal Resource Locator, e.g.: 
              http://draco.atari.org. The library recognizes the 
              required protocol reading the first part of the URL 
              (i.e. the 'http:' in example above) and then executes 
              an application associated with the protocol by an 
              appropriate environment variable. The variable must 
              contain a valid pathname to the program in question.

              Protocol  Variable        Should point to
              --------  --------        ---------------
              http:     GEMWWW=         a web browser application
              file:     GEMWWW=         a web browser application
              ftp:      GEMFTP=         an FTP client
              mail:     GEMMAIL=        an SMTP (mail) client
              news:     GEMNEWS=        a net news client
              nntp:     GEMNEWS=        a net news client
              telnet:   GEMTELNET=      a telnet client
              gopher:   GEMGOPHER=      a gopher client

              Variables should be defined in your n_aes.cnf file 
              the following way:

              export GEMWWW=u:\d\net\cab\cab.app

              The application, if found, is started in parallel 
              with the calling program.

              Alternatively if the Assemsoft's StringServer is 
              installed and up, the `url' string is passed to it 
              and evaluated as it is determined by the server 
              configuration.

Return value: 0 on success or GEMDOS error code otherwise. Status 
              -305 returned by this function means that an unknown 
              protocol identifier has been used.

@line 1 70 0

@endnode

@node "AV protocol support"
AV protocol support
@line 1 70 0

The AV protocol mostly serves for communication between programs 
and the desktop, and back. The library contains few functions which 
perform the most often used (by me) AV commands doing automatically 
as much as possible.

Since the memory protection violation is the Typically Encountered 
Problem¿ when dealing with AV protocol, because people often don't 
understand what they actually should, the library carries all this 
automatically as well. That is, no pointer to data given as an 
argument is directly passed to the AV server, but instead of that, 
the library allocates temporary buffers (with 'Readable' status), 
copies the stuff over and then sends. Hence, while using the 
library functions, you are allowed to not care about `in what type 
of the memory is the pathname I want to use in an AV command'. It 
may be private memory and you still don't bother. The buffers 
allocated by the library are released after 200 milliseconds, which 
is twice as big the time than recommended.

@{B}long av_dir_update(short drive)@{b}

Opcode:       30
Function:     tell the desktop to refresh the contents of a 
              directory window for `drive', if one is open. The 
              argument is a standard drive code, i.e. 0 for A:, 1 
              for B:, 2 for C: and so on.
Return value: 0 on success or GEMDOS error code otherwise.

@{B}long av_view(char *pathname)@{b}

Opcode:       31
Function:     displays the file specified by the `pathname' in an 
              external viewer, if such one is installed. The 
              argument can be given in one of three forms:

              1) as a single filename: foobar.txt
              2) as a relative path: foo\bar.txt
              3) as a path with leading slash: \foo\bar.txt
              4) as an absolute pathname: c:\foo\bar.txt

              The first two instances are treated as pathnames 
              relative to the current working directory of the 
              calling program. The third instance is converted to 
              an absolute path starting at drive U: (i.e. it will 
              be U:\foo\bar.txt). The fourth one is obvious. 
              Wildcards like '..' are NOT evaluated.

              Most of the dark work is done by the desktop, i.e. it 
              must determine the data type and decide which 
              application to run as a viewer. Because of that, for 
              this function to properly work, the desktop and the 
              AV server must be installed properly.

Return value: mostly 0, but also can be a negative GEMDOS error 
              code, like ENOENT when there is no running AV server.

@{B}long av_help(char *filename)@{b}

Opcode:       32
Function:     tries to open the file, whose name has been given as 
              a parameter in currently installed help system. When 
              N.AES' shel_help() call is available, the parameter 
              is passed to it. If shel_help() is not available, it 
              is assumed that the help system is ST Guide and 
              attempts to communicate with it are made, the 
              following way:

              1) if an AV server is installed, the `filename' is 
                 passed to it by a VA_START message.
              2) if no AV server is found, but ST Guide is running, 
                 the VA_START message is sent directly to it.
              3) if neither action seems possible, the variable 
                 STGUIDE= is searched for, and if it is found, the 
                 program, whose path is held by the variable, is 
                 started up with `filename' given as a parameter.

              When all this fails, the library displays an error 
              message to the user.

Return value: 0 or a GEMDOS error code.

@{B}long va_send(short cmd, char *msg, long len)@{b}

Opcode:       33
Function:     send command `cmd' to the AV server. The `msg' is the 
              pointer to the command argument (usually a string) 
              and the `len' - its length in bytes.
              The `msg' pointer does not have to point to global or 
              readable memory (the library copies it over anyway).
Comments:     This function is also used by other AV related 
              functions of the library to send commands.
Return value: 0 or a GEMDOS error code (e.g. ENOMEM).

@line 1 70 0

@endnode

@node "Other support"
Other support
@line 1 70 0

Here are other helper functions which may be, and usually are, 
useful while writing a GEM application.

@{B}long rc_intersect(RECT *src, RECT *dest)@{b}

Opcode:       9
Function:     calculates a 'result rectangle' out of two given as
              arguments. The structure RECT is defined as follows:

                typedef struct {
                        short x;
                        short y;
                        short w;
                        short h;
                } RECT;

              The function is used (also internally) to decide
              whether redraw a portion of the screen, if WM_REDRAW
              message was received. The `source' rectangle is the
              one returned by the AES from the window's rectangle
              list, whereas the `destination' one is the rectangle
              specified by the screen manager in the WM_REDRAW
              message.
Return value: returns 1, if the rectangles intersect, or 0
              otherwise.

@{B}long objc_xchange(WD *window, short obj, short newst, \
                          short redraw)@{b}
Opcode:       15
Function:     the same as the AES' objc_change() call, but the 
              clipping is made automatically.
Return value: 0

@{B}char *file_select(char *title, char *mask, ushort flag)@{b}

Opcode:       38
Function:     invokes the system file selector. `title' is the 
              string to be taken as the title of the file selector 
              window. `mask' is the default file mask.

              When $HOME is defined, the file selector opens by 
              default in the directory pointed by that variable, or 
              in the application's default directory otherwise. The 
              last selection is preserved in the memory until the 
              next call to this function (unless `flag' has its 
              highest bit set).

Caveats:      the library will run into problems, when the file to 
              select has a filename longer than 256 characters, or 
              the complete path is longer than 1024 bytes.

Return value: a pointer to the pathname selected, if the user 
              clicked OK, or NULL otherwise.

@line 1 70 0

@endnode

@node "Process management"
Process management
@line 1 70 0

@{B}long thread_fork(void *startup, void *address, \
                     char *ptitle, long stacksize)@{b}
Opcode:       13
Function:     spawn a subroutine pointed to by `address' as a
              separate process (thread). The parameter `ptitle' is
              optional and defines the name (displayed by ps) for
              the new process. If this argument is NULL, the parent
              process' name will be used.
              The parameter `stacksize' defines the stack size for 
              the new process.
              The parameter `startup' points to the thread startup
              code. Because of memory protection reasons, this is 
              normally embedded in the statically linked part of 
              the library. This startup code combined with the 
              library call is used to provide a binding that does 
              not require the `startup' parameter.

              The function automatically registers a signal handler 
              for SIGCHLD. This handler reads the result code upon
              child termination and sends a special CH_EXIT message
              to the main application via SMS server, if installed.
              If the SMS server is not installed, this action
              silently fails.

              The thread is created using Pexec(7) and started with 
              Pexec(104). Program flags for Pexec(7) are 
              automatically copied from the parent process' PROC 
              structure. Pexec(7) and subsequent Mshrink() call are 
              done under the scope of a semaphore, so that if 
              preemption occurs in the process, and another program 
              enters the thread_fork() procedure, it will be put to 
              sleep until the memory is shrunk and the semaphore is 
              released, so that the function wouldn't fail because 
              of a temporary lack of memory resources.

Return value: positive process ID (pid) of the thread or a negative
              GEMDOS error code otherwise.

@{B}long proc_exec(short mode, long flags, char *file, \
                        char *cmd, char *env)@{b}
Opcode:       41
Function:     Create a new process according to the parameters. 
              `mode' and `env' are the same as in the system 
              function P_exec(). `flags' is reserved for future 
              definition.
              For mode value of 0, 3, 100 and 200 the `file' 
              argument specifies the name of an executable file to 
              load. If no path is included, and the file is not 
              found in the current directory, it will be searched 
              in all the folders specified by the $PATH environment 
              variable. The file specified may be a shell script.
              For mode value of 5, the `file' argument should be 0.
              For mode value of 7, the `file' argument should 
              contain program flags for the new process, as defined 
              for the executable file header.
              The `cmd' argument is a pointer to the argument list, 
              which should be passed to the newly created process. 
              Unlike P_exec(), this function requires it to be a 
              normal, NULL terminated C string containing 
              subsequent arguments separated with spaces (arguments 
              which contain spaces should be enclosed in quotes). 
              This string serves as a base to construct an ARGV 
              argument list for the new process.
              For all other modes (4, 6, 104, 106, 204, 206, ...) 
              all arguments (except `flags') should conform to the 
              values defined by the appropriate system 
              documentation.
Return value: like in P_exec().

@line 1 70 0

@endnode

@node "Alert functions"
Alert functions
@line 1 70 0

Alerts are currently modal, but it is planned to change that into 
nonmodal type in future versions of the library.

@{B}long windial_alert(short button, short string)@{b}

Opcode:       14
Function:     display an alert box. `string' is an RSC index of a
              free string to be displayed as an alert box. The
              string SHOULD be formatted as for an alert box (e.g.
              exactly like the Interface program does when
              formatting alert trees).
Return value: the number of the button clicked.

@{B}void windial_error(long error, char *message)@{b}

Opcode:        18
Function:      display an "error" alert box with a text appropriate
               for the `error' parameter value (e.g. when `error'
               is -2, the message will say "Resource busy"). The
               `error' value should be negative, exactly as
               returned by GEMDOS. The library contains messages 
               for all error codes as defined by MiNT Lib's PL 55 
               /usr/include/mint/errno.h file.
               The second argument is optional and ignored when its
               value is -1. Otherwise it is treated as a pointer
               to a free string, which will be displayed in
               addition to the normal error message. The string
               should not be formatted as for an alertbox (the
               library does all necessary formatting) and should
               not exceed 40 characters in length. When it is
               necessary to split the message into two lines, you
               should use the "|" character for line break.

@line 1 70 0

@endnode

@node "Static library interface"
Static library interface
@line 1 70 0

This is a group of functions that directly interfaces the program
to the shared library, hence they are the corner stone of the
library bindings.

@{B}GEM_ARRAY *gem_control(void)@{b}

Opcode:       0
Function:     return a pointer to the application control array.
              The array is defined as follows:

              typedef struct {
                long  aesparams[6];
                short control[16];
                short global[16];
                short int_in[16];
                short int_out[16];
                long  addr_in[16];
                long  addr_out[16];
                long  vdiparams[5];
                short contrl[12];
                short intin[128];
                short ptsin[128];
                short intout[128];
                short ptsout[128];
                short vwk_handle;
                long  vwk_colors;
              } GEM_ARRAY;

              The global[0] contains the AES version number encoded 
              on four decimal digits: 0x0410 = 4.10. This number is 
              internally used by the library to decide whether the 
              appl_getinfo() call is available or not. It is 
              assumed that if the AES version is below 4.0, the 
              appl_getinfo() is not available (see Atari specs).

              The library is basically designed to work in a 
              multitasking system and with AES version >= 4.0. It 
              was not tested with old AESes.

              The field `vwk_handle' contains the current VDI 
              handle for the virtual workstation open in a result 
              of the appl_open() call. The `vwk_colors' field 
              contains the number of colors displayable at one 
              time. This number is not necessarily a precise one, 
              specifically for true colour displays it will contain 
              a value of 65536 (0x00010000).

              Since this function makes GEMDOS calls, it has been
              separated from the call_aes() to reduce GEM call
              overhead.

Caveats:      The GEM_ARRAY structure contains more (undocumented)
              fields used internally by the library.

Return value: a pointer to the application control array.


@{B}short call_aes(GEM_ARRAY *control, short function_number)@{b}

Opcode:       1
Function:     call an AES function. The `control' parameter is
              identical with the pointer returned by the
              gem_control() function above.
Caveats:      all AES calls the program does should be done via
              this function. Otherwise the library may not work
              correctly.
Return value: int_out[0] or ENOSYS, if the `function_number' 
              parameter is out of the defined range.

@line 1 70 0

@endnode

@node "Application control functions"
Application control functions
@line 1 70 0

@{B}long appl_open(char *rscfile, short thread, char *pname)@{b}

Opcode:       17
Function:     First the application is switched into MiNT domain 
              and registered in the AES with appl_init() call. When 
              the parameter `thread' is zero, and the parameter 
              `rscfile' is nonzero, it is treated as a pointer to a 
              valid GEMDOS pathname of the GEM resource file to be 
              loaded. When the parameter `thread' is nonzero, the 
              `rscfile' pointer is ignored, and a previously loaded 
              (by the parent process) resource file is utilized. It 
              will only work, if the parent process has really 
              loaded an RSC file via either appl_open() or 
              rsrc_xload() call, and if the child shares the memory 
              with him.

              If an error occurs while loading the RSC, the
              application registration gets cancelled by a call to
              appl_exit().

              The parameter `pname' is the application's name for 
              the "Desk" menu. If this is -1, the parameter is 
              ignored. If its value is below 65536, it is 
              understood as a resource index of a free string in 
              the resource file just loaded. Contrary, if it is 
              greater than 65535, it is understood as an address of 
              a free string which should be taken as the 
              application's name.

              When the action above succeeds, the AES is 
              additionally told the application recognizes the 
              AP_TERM message and a basic VDI virtual workstation 
              is open.

Return value: AES application ID on success, or a negative error
              code otherwise.

@{B}long appl_top(void)@{b}

Opcode:       25
Function:     Top the application, if possible.
Return value: 0 on success or a negative error code otherwise 
              (currently this is ENOSYS standing for "invalid AES 
              function call").

@{B}long appl_close(void)@{b}

Opcode:       39
Function:     Closes the virtual workstation that was open by 
              appl_open(), releases the resource file (if loaded) 
              by a call to rsrc_xfree() and leaves the GEM with 
              appl_exit().
Return value: currently always 0 (success).

@line 1 70 0

@endnode

@node "Resource file related functions"
Resource file related functions
@line 1 70 0

@{B}long rsrc_xload(char *rscfile)@{b}

Opcode:       10
Function:     Cache the specified GEM resource file in the memory.
Caveats:      This is a custom library call, you cannot use
              rsrc_load() instead.
Return value: 0 on success or a negative error code otherwise.

@{B}long rsrc_xalloc(void)@{b}

Opcode:       11
Function:     Fixup the raw RSC file previously cached by the
              rsrc_xload() call.
Caveats:      This is a custom library call, you cannot use 
              rsrc_rcfix() instead.
Return value: 0 on success or a negative error code otherwise.

@{B}long rsrc_xfree(void)@{b}

Opcode:       12
Function:     Release the RSC file previously loaded with
              appl_open() or rsrc_xalloc().
Caveats:      This is a custom library call, you cannot use 
              rsrc_free() instead.
Return value: 0 on success or a negative error code otherwise.

@line 1 70 0

@endnode

@node "Environment functions"
Environment functions
@line 1 70 0

@{B}char *env_get(const char *variable)@{b}

Opcode:       21
Function:     Finds the specified variable in the application
              environment string. The variable name (pointed to by
              the argument) must be a NULL terminated string ended
              with the "=" character. For example, to find the
              value of the $HOME, the function call should look as
              follows:

                char *home;

                home = env_get("HOME=");

              The returned value specifies the variable litterally
              as it is defined in the environment, no conversion or
              evaluation is made.
Return value: a pointer to the variable value or NULL, if the
              specified variable does not exist.

@{B}char *env_eval(const char *variable)@{b}

Opcode:       22
Function:     This is similar to the env_get(), except that the
              variable, if found, is additionally processed as
              indicated by the $UNIXMODE variable.               

              Furthermore, each variable is evaluated, so that a
              part of it (or an entire variable) can be defined by
              another one. For example, for a definition like:

                setenv HOME u:\root
                setenv MYDIR $HOME

              the $MYDIR will be evaluated and returned as
              `u:\root'. Similarly, if you define

                setenv HOME u:\root
                setenv MYDIR $HOME
                setenv DEFAULTS $MYDIR\defaults
                setenv CONFIGFILE $DEFAULTS\config.inf

              the env_eval("CONFIGFILE=") will return
              `u:\root\defaults\config.inf', whereas env_get()
              only returns `$DEFAULTS\config.inf' in this case.
Caveats:      - the recursion depth is limited to 64 levels.
              - the maximum recursion depth requires about 16k free
                stack space, and you should provide at least this
                much in case there is a circular reference between
                variables.
              - variables $PCONVERT and $UNIXMODE cannot be defined
                indirectly, because their values are used as
                arguments for the evaluation (references to other
                variables found in these two are ignored).
              - the variable $SLBPATH cannot be defined this way, 
                because it is evaluated by the kernel and the code 
                dealing with that is not so intelligent, for the 
                sake of speed.
Return value: a pointer to the result string on success or NULL on
              failure.

@{B}long env_getargc(void)@{b}

Opcode:       23
Function:     returns the number of ARGV arguments.

@{B}char *env_getargv(short argc)@{b}

Opcode:       24
Function:     returns a pointer to the ARGV argument number `argc',
              or NULL, if there is no such argument.

@line 1 70 0

@endnode

@node "Windowed dialog management"
Windowed dialogs
@line 1 70 0

Routines for creating and managing windowed dialogs are the corner 
stone of the library. In most cases, an application must only 
provide memory for the WD structure which contains all the 
information needed by the library to properly handle a window. The 
structure is completely filled in and managed by the library so 
that in most cases the programmer does not have to worry on the 
sturcture's contents. The structure is defined by the source files 
supplied along with the library.

@{B}long windial_size(void)@{b}

Opcode:       2
Function:     returns the minimum size of the WD structure for a 
              single windowed dialog box. Your program should 
              provide at least this much for each window it needs 
              to create. It is guaranteed that the number returned 
              by this function is the same for all dialog boxes the 
              program needs to create - it only can be different 
              across different versions of the lib.

@{B}long windial_create(WD *window, short box, short icon, \
                         short ftext, char *title)@{b}

Opcode:       3
Function:     initializes the window structure in the memory buffer 
              pointed to by the `window' parameter. If the `window' 
              is NULL, the function will first allocate the needed 
              memory buffer (freed later by the windial_delete() 
              function), though it is not an optimal choice.
              `box' is the resource index of the dialog box object 
              tree. This parameter is obligatory.
              `icon' is the resource index of the icon object tree. 
              If this parameter is 0, the dialog box won't have the 
              iconifier gadget and no iconification will be 
              possible.
              `ftext' is the resource index of the first editable 
              textfield found in the object `box'. If there are no 
              editable textfields in the box, the parameter should 
              be 0.
              `title' is a pointer to a free string which will be 
              used as the window's title displayed on its title 
              bar. When no title is required, the pointer should 
              point to an empty string (""), but also may be -1. 
              When this parameter's value is below 65536, it is 
              understood as a resource index of the RSC file loaded.

              Exactly like the AES function wind_create(), this one 
              does not display any window. After a successful 
              return, the structure WD initialized by the function 
              can be manipulated so that the subsequent 
              windial_open() call will display the window e.g. in 
              an arbitrary location rather than the default one.

Return value: returns a pointer to the WD structure, or 0 if the 
              function failed.

@{B}long windial_open(WD *window)@{b}

Opcode:       4
Function:     opens the windowed dialog box as defined by the 
              parameter.
Return value: currently 0 (success).

@{B}long windial_formdo(WD *window)@{b}

Opcode:       5
Function:     similarly to the AES' form_do(), the function is 
              monitoring the user interaction with the dialog box, 
              or dialog boxes, if multiple are displayed at a time. 
              Window events, like move, iconify, uniconify, full, 
              top, untop etc. and also editable textfields, are 
              handled automatically inside the library without 
              arranging the main application.
Return value: the returned longword contains the resource index of 
              the object clicked in the low word and the resource 
              index of the object tree where the object belongs to 
              in the high word. If the user clicked the closer 
              gadget, a value of -1 is returned for the object 
              index.
              When your program only displays one dialog at a time, 
              the high word can be safely ignored.
Caveat:       if windial_setjmp() was used to define an alternative 
              event handler, this function may never return.

@{B}long windial_close(WD *window)@{b}

Opcode:       6
Function:     closes the specified window. The window's structure 
              in the memory is not released so that it can be 
              reopened by windial_open().
Return value: currently 0 (success).

@{B}long windial_delete(WD *window)@{b}

Opcode:       7
Function:     deletes the specified window. The window's structure 
              in the memory is released so that it cannot be 
              reopened by windial_open() without a previous call to 
              windial_create().
Return value: currently 0 (success).

@{B}long windial_center(WD *window)@{b}

Opcode:       8
Function:     performs the window positioning at the centre of the 
              screen.
Return value: currently 0.

@{B}long windial_dup(WD *old, WD *new)@{b}

Opcode:       19
Function:     duplicates a window defined by the `old' parameter 
              and initializes the `new' structure, so that the 
              `new' window being a copy of the `old' one can be 
              opened with windial_open() without a separate call to 
              the windial_create(). As with windial_create(), the 
              `new' parameter can be NULL and in such a case the 
              required memory will be allocated automatically.
              When both windows are opened simultaneously, the 
              windial_formdo() routine handles both.
Return value: 0 on success or a negative error code otherwise.

@{B}long windial_link(WD *from, WD *to)@{b}

Opcode:       20
Function:     two windows created independently with two separate 
              windial_create() calls are linked together, so that 
              the windial_formdo() routine can automatically switch 
              from one to another handling them both as necessary.
Return value: 0 on success or a negative error code otherwise.

@{B}long windial_unlink(WD *window)@{b}

Opcode:       27
Function:     unlinks the specified window from the linked list 
              created by windial_link(). The window's structure is 
              simultaneously invalidated, so that it cannot be 
              linked back. For this reason it is more advisable to 
              use windial_delete(), which performs unlinking 
              automatically.
Return value: currently 0. In case of an error the function 
              silently fails.

@line 1 70 0

@endnode

@node "External event handlers"
External event handlers
@line 1 70 0

Here are functions which allow you to intercept and modify the 
operation of the event handlers provided by the library.

@{B}long windial_setjmp(WD *window, short vec, void *adr)@{b}

Opcode:       26
Function:     registers an external handler for events which are 
              not handled internally by the library. This is mainly 
              intended for the AP_TERM and VA_START messages, but in fact 
              any type of the standard GEM events can be intercepted this 
              way. Each window can have own separate subset of such 
              handlers (or can have none).
              The `vec' parameter contains the "vector number" for 
              the required type of events. Currently these vectors 
              are defined as follows:

              Vec       Handling
              ---       --------
               0        AES messages
               1        keyboard events
               2        mouse button events
               3        mouse rectangle events
               4        alternative mouse rectangle events
               5        timer events

              Of that number, handlers 0 and 1 are local for each 
              window (i.e. each window can have different handler), 
              whereas handlers 2-5 are global for all windows.
              The parameter `adr' is the new value of the vector 
              `vec', i.e. the entry point for the new handler.

              The point defined by this argument *** MUST *** find 
              itself in the same stack context as the initial call 
              to the windial_setjmp() was, or else stack corruption 
              may occur.

              The handler setup by this function is called before 
              (if at all) the associated event is handled by the 
              library routines, and accepts stacked arguments:

              Vec       Handler prototype
              ---       -----------------
               0        long newmsg(WD *wd, short vec, (void *)msg)
               1        long newkey(WD *wd, short vec, short ks, \
                                                        short kc)
               2        (not yet defined)
               3        (not yet defined)
               4        (not yet defined)
               5        long newtmr(WD *wd, short vec, long timer)

              Where `wd' is a pointer to the structure of the 
              window, that generated the event (undefined for 
              handlers 2-5), `vec' is the vector number, `msg' is 
              a pointer to the AES message buffer, `ks' is a word 
              containing the state of the keyboard shift keys, `kc' 
              is the keycode and `timer' is the start value of the 
              evnt_timer().

              The handler once entered and has done what was 
              supposed necessary, may behave three ways. First, it 
              can just return with a long value of 0 in the d0 
              register, which means it wishes the event to be 
              further processed by the library routines. In an 
              opposite case, when no further processing is 
              required, a long value of -1 should be returned. 

              The keyboard handler has an additional function here: 
              if the returned value is greater than a zero, it is 
              interpreted as the new keycode. After return to the 
              library, its routines do further processing using the 
              code returned.

              Eventually, the windial_longjmp() may be called, which 
              performs an exit from the event loop and jumps back 
              here to return to the program exactly at the same 
              point where the windial_setjmp() was originally 
              called.

Return value: 0 on success or EINVAL when invalid argument was 
              specified (particularly `vec' is out of range) while 
              setting the jump. While returning from 
              windial_longjmp() this function returns 1.

@{B}void windial_longjmp(WD *window, short vec)@{b}

Opcode:       28
Function:     returns from the event handler (see above), restores 
              the stack context to the state recorded by the 
              windial_setjmp() call, then jumps back to the 
              windial_setjmp() function.
              The function of this call is similar to the operation 
              made by the sigreturn() and longjmp() when returning 
              from kernel signal handlers.
Return value: this function never returns.

@line 1 70 0

@endnode

@node "Library functions listed by opcode"
Library functions listed by opcode
@line 1 70 0

Opcode          Function prototype
------          ------------------
  0             GEM_ARRAY *gem_control(void)
  1             long call_aes(GEM_ARRAY *ctrl, short opcode)
  2             long windial_field(void)
  3             long windial_create(WD *window, short box, short icon, \
                                    short ftext, char *title)
  4             long windial_open(WD *window)
  5             long windial_formdo(WD *window)
  6             long windial_close(WD *window)
  7             long windial_delete(WD *window)
  8             long windial_center(WD *window)
  9             long rc_intersect(RECT *src, RECT *dest)
  10            long rsrc_xload(char *filename)
  11            long rsrc_xalloc(void)
  12            long rsrc_xfree(void)
  13            long thread_fork(void *stub, void *func, char *ptitle, \
                                 long stksize)
  14            long windial_alert(short button, short object)
  15            long objc_xchange(WD *window, short obj, short newst, \
                                    short redraw)
  16            void *rsrc_xgaddr(short type, short object)
  17            long appl_open(char *filename, short thread, char *pname)
  18            long windial_error(long error, char *usermsg)
  19            long windial_dup(WD *old, WD *new)
  20            long windial_link(WD *from, WD *to)
  21            char *env_get(char *var)
  22            char *env_eval(char *var)
  23            long env_getargc(void)
  24            char *env_getargv(short argc)
  25            long appl_top(void)
  26            long windial_setjmp(WD *window, short vec, void *adr, \
                                        void *link)
  27            long windial_unlink(WD *window)
  28            void windial_longjmp(WD *window, short vec)
  29            void ftext_init(short tree, short obj)
  30            long av_dir_update(short drive)
  31            long av_view(char *pathname)
  32            long av_help(char *filename)

  38            char *file_select(char *title, short flag)
  39            long appl_close(void)
  40            long open_url(char *url)
  41            long proc_exec(short mode, long flags, \
                                char *file, char *cmd, char *env)
@line 1 70 0

@endnode

@node "CHANGES"
CHANGES
@line 1 70 0

TODO:

- finish and test env_*() functions
- finally do the multidialog support, as advertised
- code the nonmodal alerts
- add font selection support
- support the xrsrc
- emulate whitebak objects where not directly supported

Version 1.07

- added function 41, proc_exec()
- env variable names for open_url() changed to avoid conflicts with 
  text based, or other gui based applications.

Version 1.06

- the entire library has been rewritten in C and compiled with
  gcc 2.95.2.
- all functions have been extended with an additional parameter. 
  The application can now maintain the pointer to its GEM_ARRAY and 
  pass it to the library along with other function parameters. This 
  allows to greatly reduce the function call overhead inside the 
  library.
  This extension is compatible with previous versions of the 
  library. Programs compiled for the last assembler version of the 
  gemma.slb (i.e. 1.04) should still work.
- internal reorganization and revision for all of the code allowed 
  to reduce function overhead, memory requirements, and also to do 
  many bugfixes here and there.
- windial_alert() now accepts char * as the second parameter. This 
  extension is compatible with previous versions of the library: 
  when no third parameter is passed, the old calling style is 
  assumed and the arguments are adjusted appropriately.
- all functions now return EACCES when no appl_init() was called 
  before.
- removed redundant code in windial_center()
- the WINDIAL structure (one copy) is now integrated into the 
  internal application structure maintained by the library and 
  automatically assigned to the first windowed dialog the program 
  creates without assigning it a predefined memory block. This 
  saves some memory in case of programs which display only one 
  window.
- the `mask' parameter for file_select() is no longer ignored,
  neither is `flag'.
- bugfixes in initialization of the object tree for screen modes 
  with less than 16 colours (should be recursive though)
- fixed bug in av_dir_update(), the AES version number instead of 
  the sender apid was sent to the AV server :>
- operations on window objects, when it is iconified, should work 
  now.
- added functions: va_send(), get_users(), get_version().

Version 1.05 is skipped

Version 1.04

- editable text fields can be now activated with a mouse click
- windial_create() now automatically initializes editable text 
  fields starting from the object given as the first field.
- call_aes() expanded to recognize N.AES calls objc_xfind(), 
  graf_multirubber(), form_popup().
- windial_create() now recognizes additional parameter defining 
  gadgets. The alternative binding for C is named windial_xcreate().
- call_aes() now recognizes MagiC wdlg_*() calls (but they aren't
  emulated).

1.XI.2000.

- rsrc_xgaddr() now goes through the common calling sequence, and 
  all internal calls to rsrc_gaddr() go through rsrc_xgaddr().
- memory page size is now read from the system, if this is 
  impossible, 8k is assumed.
- rsrc_xalloc() now checks whether the functions it uses are 
  present and supported by the AES.
- some functions verify input addresses before calling the AES. 
  This is to prevent the AES from bombing down when an invalid 
  address is specified. Since the verification is done by touching 
  the address, the faulty process will die, but the system will 
  survive.
- fixed a bug that made programs crash when rsrc_rcfix() was not
  present, the library clients now less or more work under XaAES.
- windial_error() was full of nasty bugs and I am surprised it 
  worked at all.
- introduced vertical positioning compensation, depending on a flag 
  in the header.

Version 1.03

- fixed bad bug related to iconification
- included VDI support, appl_open() now opens the VDI
- appl_close() function added.
- appl_open() now does menu_register()
- functions preserve all registers, this solves problems with gcc 
  programs.
- appl_open(), windial_create() and windial_error() now 
  automatically convert RSC indexes into addresses for free strings 
  given as parameters.
- made windial_setjmp() & windial_longjmp() calls
- added fileselector support
- more bugfixes
- appl_open() returns all errors to the caller again
- fixed wrong definition of the call_aes() in gemma.h
- fixed a bug in the event handler that caused the library to loss
  keystrokes sometimes.

Version 1.02

- added functions ftext_init(), av_dir_update(), av_view(), 
  av_help(), open_url()
- redefined the order and number of the stacked arguments passed to 
  the external event handlers (this breaks compatibility with 
  previous versions).
- added handling external handler vector 5 (evnt_timer)
- memory allocations done by the library are now under the scope of 
  a semaphore (the same one as in thread_fork())
- removed separator conversions in paths, this is not required by 
  MiNT and not necessary on other systems.
- appl_open() now switches into MiNT domain and registers AP_TERM 
  message in the system.
- added StringServer support.
- appl_open() now displays a message and terminates the program, if 
  appl_init() fails.
- removed an unused buffer

Version 1.01

- various tests and bugfixes

Version 1.00

- initial version, quite buggy and limited.

@line 1 70 0

@endnode
