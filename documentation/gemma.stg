@database "The GEM application support library"
@author   "Draco (draco@atari.org)"
@subject  Documentation/Manual
@$VER: gemma.stg (@:"__DATE__")
@options "-s +i +zz"

@node "Main"
@title "The GEM application support library"
@line 1 70 0

@{B}          GEMMA, the GEM application support library@{b}

@line 1 70 0

        License

        Why to use shared libraries?

        I.    Installation

        II.   Function description

              1. Static library interface
              2. Application control functions
              3. Resource file related functions
              4. Environment functions
              5. Windowed dialog management
              6. External event handlers
              7. Alert functions
              8. Process management
              9. AV protocol support
             10. Invoking standard applications
             11. Other support

        III.  Library functions listed by opcode

        IV.   Programming

        V.    Incompatibilities

        VI.   Emulation

        VII.  Accompanied libraries

        VIII. CHANGES

@line 1 70 0

@endnode

@node "Why to use shared libraries?"
Why to use shared libraries?
@line 1 70 0

This is very true, that almost every program uses a library. This
especially applies to programs written in high-level languages like
C, Pascal, BASIC, but is also true for many assembler programs. In
the latter case the library usually contains the most common
procedures used by a programmer, while in the former case libraries
are more unified - still, they contain the most common routines
used in programs.

However, most TOS, and even MiNT programs use statically linked
libraries. This means, that the library and the program, that uses
it, are linked in one binary file, and are rather indivisible. This
solution has many advantages, but also one big disadvantage: when
you discover a bug in the library, you cannot replace it with newer
one so that older programs could work better. Also, when you load
10 programs linked with the same library, you have 10 copies of the
same library loaded to the memory.

These problems are not present, when you use shared objects like
gemma.slb is. A shared library is loaded to the memory only once:
even if 100 programs use it at the same time, only one copy of the
library is present in the memory. Also, when the library is buggy,
you can fix it and replace with newer version, and this change
affects all programs which use the library.

@line 1 70 0

@endnode

@node "License"

    Gemma, support library for GEM application programs.
    Copyright (C) 1999-2003 Draco/YC

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License as
    published by the Free Software Foundation; either version 2 of
    the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public
    License along with this program; if not, write to the Free
    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
    USA.

@endnode

@node "Incompatibilities"
Incompatibilities
@line 1 70 0

This is a list of differences between the established SLB standard
and the behaviour of the gemma.slb:

- the library is compiled without -mshort, and this means that all
  stacked arguments must be 32-bit.
- the third argument of every library call is simply the number of
  the remaining arguments, and NOT the size of the arguments in
  words.

@endnode

@node "Programming"
Programming
@line 1 70 0

This information is for programmers wishing to use the SLB in own
(gcc) programs. This is pretty straighforward:

I. Headers and static modules

- function prototypes and structure definitions are inside the
  header file gemma.h, which belongs to /usr/include/gemma folder.
  If you #include <slb/gemma.h>, you do NOT need to include
  gem.h, the usual header for GEM programs.

- definitions needed for an SLB, but not belonging to the Gemma
  library are inside the header file slb.h. This belongs to the
  /usr/include/mint folder and is automatically included by the
  gemma.h header.

- your program, once compiled, must be linked against libgemma.a
  and libslb.a (exactly in this order: -lgemma -lslb). Both
  libraries get built when you type `make' at the top level of the
  directory structure created by unpacking the source archive.
  After the libraries are compiled, you copy the contents of the
  lib/ subdirectory to your /usr/lib.

  See Incompatibilities

@{B}libslb.a@{b}
This module is responsible for the actual opening an SLB. It
provides a function called _slbload() which opens the named SLB and
returns on success or prints a brief error message on failure.
You do not have to call the _slbload() yourself, it is done
automatically, in appl_open().

@{B}libgemma.a@{b}
This module contains bindings for AES function calls. These
bindings are not the same as in the GEMLib, since here the AES
calls are done via the shared library. Also, this module is
responsible for opening the library - via a call to the _slbopen()
mentioned above - and initializing all the necessary stuff either
inside the libgemma module and inside the shared object. All this
is done by the appl_open() you call at the begin of your program.

II. Other info

- there is NO support for -mshort programs.
- you should provide at least 16k room on the stack in your program
  for the correct execution of the SLB functions.

III. Writing programs with gemma.slb

The library consists of the shared object called gemma.slb and
static module libgemma.a. To use the shared object your program
must be statically linked with libgemma.a.

The statically linked object consists of many short routines. These
are mostly bindings for standard AES calls. The prototypes for
these bindings are the same as in GEMLib, however, the bindings
themselves are not the same. The main difference is that they do
not trap to the AES directly but pass the application calls to the
shared object. Prototypes are provided by gemma.h header file.

The shared object, apart of the AES interface, also contains 46
more or less complex functions. In your program you can use
standard AES functions and complex library functions, but only
under the condition, that all AES calls your application uses go
through the gemma.slb. In other words, you cannot use other
bindings, than these which are provided by libgemma.a, not other
prototypes, than these which are provided by gemma.h.

The procedure of writing GEM program using gemma.slb is exactly the
same, as with other libraries. With one exception: you DON'T use
appl_init() as the first GEM call in your program, and you DON'T
use appl_exit() as the last one. In fact, these two are useless,
and bindings are only provided for consistency. Instead, you use
appl_open() in place of appl_init() and appl_close() in place of
appl_exit(). Calling the appl_open() causes the shared object to be
loaded to the memory (or just to be opened, when it had already
been loaded by another application). Similarly, the appl_close()
causes the shared object to be closed and unloaded.

After that you can create a windowed dialog using windial_create(),
open it to the screen using windial_open() and let the library handle
it using windial_formdo(). The windial_formdo() function does
everything it can do for you, i.e. automatically handles most
events your window can receive (such as topping, untopping,
iconifying, moving etc.) and returns your information about objects
clicked by the user.

Many windowed dialogs may be handled such way simultaneously.

@line 1 70 0

@endnode

@node "Installation"
Installation
@line 1 70 0

This is my GEM application support library. It mostly consists of
functions I have written while developing bigger or smaller
programs. Since I am lazy and really dislike writing the same code
sequences again and again, I've decided to include all this in a
library. And here it is.

The library upto version 1.04 was written entirely in assembler and
was intended as a support for assembler programs. But it will
probably work for other languages too, particularly for the C
language. Now, since version 1.06 the library development continues
in C - however, in turn, this does not mean that it cannot be used
with programs written in other languages, including assembler.

The backside of the conversion done is, that MagiC users will
probably not be able to use the compiled binary directly. This is
because the gcc only produces binaries in the extended executable
format, and SLBs in this format will probably not be accepted by
MagiC.

The library is (obviously) multitasking safe and memory protection
clean.

@{B}How to install@{b}

Unless otherwise specified in the documentation of a program which
uses the library, the best choice is to put the gemma.slb into a
folder where other such libs live. On my system this is
/usr/local/lib/slb/ (i.e. u:/usr/local/lib/slb) but you can
obviously choose another location as well.

The folder must be pointed to by the $SLBPATH environment variable.
You define this by adding a line like:

setenv SLBPATH u:/the/path/where/you/keep/libs

to your mint.cnf file. As of MiNT 1.16.0 the variable may contain
a list of folders to search by (like $PATH).

If you already have an older version of the gemma.slb in that
folder, you will probably have to replace it with newer one. If the
folder is on a filesystem, which supports 'x-bits' (e.g. minix or
ext2), you also have to set the x flags for each SLB file there or
the system won't load them otherwise.

If you have programs which use the gemma.slb, you should also
install the SMS server, which is a separate program used by the
library for more functionality, when present. The server is
available on the web under the following addresses:

http://draco.atari.org

Also installing the Assemsoft's StringServer is recommended. The
StringServer can be downloaded at http://assemsoft.atari.org.

If you don't have StringServer installed, it is advised to define
the following environment variables (all, or at least the first
one):

GEMWWW=[here the full path to your WWW browser]
GEMFTP=[the full path to your FTP client]
GEMMAIL=[the full path to the mailer program]
GEMTELNET=[the full path to the telnet program]
GEMNEWS=[the full path to the news reader]
GEMGOPHER=[the full path to the gopher client]

If you don't have some of programs mentioned above, don't worry,
just don't define the variable.

Have fun,
draco@atari.org

Warszawa, December 2003

@line 1 70 0

@endnode

@node "Invoking standard applications"
Invoking standard applications
@line 1 70 0

Almost every system (well, most of them) has several daily programs
of similar or even the same type: a text editor, a text viewer, a
CLI, a web browser et cetera. For a developer working in a
multitasking environment it is extremely handy to have a
standardized way of invoking such useful applications from within a
program instead of being forced to code everything from scratch
each time one needs a viewer.

There is much of this functionality in the desktop's AV protocol,
which e.g. supplies the way of invoking a viewer for any data type
known to the shell application (desktop), see the chapter entitled
AV protocol support somewhere within this document. However, not
everything can be done this way and thus the library provides
methonds to access other applications as well, just to save your
efforts.

@{B}long open_url(char *url)@{b}

Opcode:       40
Function:     execute an appropriate network client handing the
              parameter off to it. The `url' must be a NULL
              terminated string formatted in the normal form of the
              Universal Resource Locator, e.g.:
              http://draco.atari.org. The library recognizes the
              required protocol reading the first part of the URL
              (i.e. the 'http:' in example above) and then executes
              an application associated with the protocol by an
              appropriate environment variable. The variable must
              contain a valid pathname to the program in question.

              Protocol  Variable        Should point to
              --------  --------        ---------------
              http:     GEMWWW=         a web browser application
              file:     GEMWWW=         a web browser application
              ftp:      GEMFTP=         an FTP client
              mail:     GEMMAIL=        an SMTP (mail) client
              news:     GEMNEWS=        a net news client
              nntp:     GEMNEWS=        a net news client
              telnet:   GEMTELNET=      a telnet client
              gopher:   GEMGOPHER=      a gopher client

              Variables should be defined in your n_aes.cnf file
              the following way:

              export GEMWWW=u:\d\net\cab\cab.app

              The application, if found, is started in parallel
              with the calling program.

              Alternatively if the Assemsoft's StringServer is
              installed and up, the `url' string is passed to it
              and evaluated as it is determined by the server
              configuration.

Return value: 0 on success or GEMDOS error code otherwise. Status
              -305 returned by this function means that an unknown
              protocol identifier has been used.

@line 1 70 0

@endnode

@node "AV protocol support"
AV protocol support
@line 1 70 0

The AV protocol mostly serves for communication between programs
and the desktop, and back. The library contains few functions which
perform the most often used (by me) AV commands doing automatically
as much as possible.

Since the memory protection violation is the Typically Encountered
Problem(tm) when dealing with AV protocol, because people often don't
understand what they actually should, the library carries all this
automatically as well. That is, no pointer to data given as an
argument is directly passed to the AV server, but instead of that,
the library allocates temporary buffers (with 'Readable' status),
copies the stuff over and then sends. Hence, while using the
library functions, you are allowed to not care about `in what type
of the memory is the pathname I want to use in an AV command'. It
may be private memory and you still don't bother. The buffers
allocated by the library are released after 200 milliseconds, which
is twice as big the time than recommended.

@{B}long av_dir_update(short drive)@{b}

Opcode:       30
Function:     tell the desktop to refresh the contents of a
              directory window for `drive', if one is open. The
              argument is a standard drive code, i.e. 0 for A:, 1
              for B:, 2 for C: and so on. The value of -1 tells
              the shell to update all windows.

Comments:     under AES 4.0 and up the function will work also when
              no AV server is available.

Return value: 0 on success or GEMDOS error code otherwise.

@{B}long av_view(char *pathname)@{b}

Opcode:       31
Function:     displays the file specified by the `pathname' in an
              external viewer, if such one is installed. The
              argument can be given in one of three forms:

              1) as a single filename: foobar.txt
              2) as a relative path: foo\bar.txt
              3) as a path with leading slash: \foo\bar.txt
              4) as an absolute pathname: c:\foo\bar.txt

              The first two instances are treated as pathnames
              relative to the current working directory of the
              calling program. The third instance is converted to
              an absolute path starting at drive U: (i.e. it will
              be U:\foo\bar.txt). The fourth one is obvious.
              Wildcards like '..' are NOT evaluated.

              Most of the dark work is done by the desktop, i.e. it
              must determine the data type and decide which
              application to run as a viewer. Because of that, for
              this function to properly work, the desktop and the
              AV server must be installed properly.

Return value: mostly 0, but also can be a negative GEMDOS error
              code, like ENOENT when there is no running AV server.

@{B}long av_help(char *filename)@{b}

Opcode:       32
Function:     tries to open the file, whose name has been given as
              a parameter in currently installed help system. When
              N.AES' shel_help() call is available, the parameter
              is passed to it. If shel_help() is not available, it
              is assumed that the help system is ST Guide and
              attempts to communicate with it are made, the
              following way:

              1) if an AV server is installed, the `filename' is
                 passed to it by a VA_START message.
              2) if no AV server is found, but ST Guide is running,
                 the VA_START message is sent directly to it.
              3) if neither action seems possible, the variable
                 STGUIDE= is searched for, and if it is found, the
                 program, whose path is held by the variable, is
                 started up with `filename' given as a parameter.

              When all this fails, the library displays an error
              message to the user.

Return value: 0 or a GEMDOS error code.

@{B}long va_send(short cmd, char *msg, long len)@{b}

Opcode:       33
Function:     send command `cmd' to the AV server. The `msg' is the
              pointer to the command argument (usually a string)
              and the `len' - its length in bytes.
              The `msg' pointer does not have to point to global or
              readable memory (the library copies it over anyway).
Comments:     This function is also used by other AV related
              functions of the library to send commands.
Return value: 0 or a GEMDOS error code (e.g. ENOMEM).

@line 1 70 0

@endnode

@node "Other support"
Other support
@line 1 70 0

Here are other helper functions which may be, and usually are,
useful while writing a GEM application.

@{B}long rc_intersect(GRECT *src, GRECT *dest)@{b}

Opcode:       9
Function:     calculates a 'result rectangle' out of two given as
              arguments. The structure GRECT is defined in gemma.h.
              The function is used (also internally) to decide
              whether a portion of the screen should be redrawn, if
              WM_REDRAW message was received. The `source'
              rectangle is the one returned by the AES from the
              window's rectangle list, whereas the `destination'
              one is the rectangle specified by the screen manager
              in the WM_REDRAW message.
Return value: returns 1, if the rectangles intersect, or 0
              otherwise.

@{B}long objc_xchange(WD *window, short obj, short newst, \
                          short redraw)@{b}
Opcode:       15
Function:     the same as the AES' objc_change() call, but the
              clipping is made automatically.
Return value: 0

@{B}long objc_xdraw(WD *window, short obj@{b}
Opcode:       35
Function:     the same as the AES' objc_draw() call, but the
              clipping is automatically made to the work area of
              the `window', and maximum depth is assumed.
Comments:     This function was previously available as an
              alternative binding for objc_draw() and has been
              moved into the library as of version 1.08.
Return value: 0

@{B}char *file_select(char *title, char *mask, ushort flag)@{b}

Opcode:       38
Function:     invokes the system file selector. `title' is the
              string to be taken as the title of the file selector
              window. `mask' is the default file mask.

              When $HOME is defined, the file selector opens by
              default in the directory pointed by that variable, or
              in the application's default directory otherwise. The
              last selection is preserved in the memory until the
              next call to this function (unless `flag' has its
              highest bit set).

Caveats:      the library will run into problems, when the file to
              select has a filename longer than 256 characters, or
              the complete path is longer than 1024 bytes.

Return value: a pointer to the pathname selected, if the user
              clicked OK, or NULL otherwise.

@{B}char *get_version(void)@{b}

Opcode:       42
Function:     returns a pointer to a NULL terminated string
              containing version and copyright information for
              the library.

@{B}long get_users(void)@{b}

Opcode:       43
Function:     returns the actual number of current library users
              (i.e. number of processes that have opened the lib).

@line 1 70 0

@endnode

@node "Process management"
Process management
@line 1 70 0

@{B}long thread_fork(void *startup, void *address, \
                     char *ptitle, long stacksize, long opt)@{b}
Opcode:       13
Function:     spawn a subroutine pointed to by `address' as a
              separate process (thread). The parameter `ptitle' is
              optional and defines the name (displayed by ps) for
              the new process. If this argument is NULL, the parent
              process' name will be used.
              The parameter `stacksize' defines the stack size for
              the new process.
              The parameter `flag', if bit 0 of it is set, prevents
              the function from registering the SIGCHLD handler
              (see below).
              The parameter `startup' points to the thread startup
              code. Because of memory protection reasons, this is
              normally embedded in the statically linked part of
              the library. This startup code combined with the
              library call is used to provide a binding that does
              not require the `startup' parameter.

              The function automatically registers a signal handler
              for SIGCHLD. This handler reads the result code upon
              child termination and sends a special CH_EXIT message
              to the main application via SMS server, if installed.
              If the SMS server is not installed, this action
              silently fails.

              The thread is created using Pexec(7) and started with
              Pexec(104). Program flags for Pexec(7) are
              automatically copied from the parent process' PROC
              structure. Pexec(7) and subsequent Mshrink() call are
              done under the scope of a semaphore, so that if
              preemption occurs in the process, and another program
              enters the thread_fork() procedure, it will be put to
              sleep until the memory is shrunk and the semaphore is
              released, so that the function wouldn't fail because
              of a temporary lack of memory resources.

Return value: positive process ID (pid) of the thread or a negative
              GEMDOS error code otherwise.

@{B}long proc_exec(short mode, long flags, char *file, \
                        char *cmd, char *env)@{b}
Opcode:       41
Function:     Create a new process according to the parameters.
              The function operates like the Pexec(mode) in GEMDOS,
              except:

              1) for mode value of 0, 3, 100 and 200 the `file'
                 argument specifies the name of an executable file
                 to load. If no path is included, and the file is
                 not found in the current directory, it will be
                 searched in all the folders specified by the $PATH
                 environment variable.
              2) the file specified may be a shell script; in order
                 to execute it the library will invoke the shell as
                 specified in the script. If the script does not
                 contain the full path to the proper interpreter,
                 and only the file name is specified, $PATH
                 searching will be performed before doing anything
                 further.
              3) the `cmd' argument is a pointer to the argument
                 list, which should be passed to the newly created
                 process. Unlike for Pexec(), this must be
                 a normal, NULL terminated C string containing
                 subsequent arguments separated with spaces
                 (arguments which contain spaces themselves should
                 be enclosed in quotes). This string is NOT limited
                 in length to 126 bytes.
              4) in order to be able to pass long argument list the
                 library constructs the ARGV= list in the
                 environment of the process to be created.

              For all other modes (4, 6, 104, 106, 204, 206, ...)
              all arguments (except `flags') should conform to the
              values defined by the appropriate system
              documentation.

              If the bit 0 of the `flags' argument is set to 1, the
              new process will be executed with its standard output
              stream redirected to NULL.

Return value: like in P_exec().

@line 1 70 0

@endnode

@node "Alert functions"
Alert functions
@line 1 70 0

Alerts are currently modal, but it is planned to change that into
nonmodal type in future versions of the library.

@{B}long windial_alert(short button, char *string)@{b}

Opcode:       14
Function:     display an alert box. `string' may be an RSC index of
              a free string to be displayed as an alert box. The
              string SHOULD be formatted as for an alert box (e.g.
              exactly like the Interface program does when
              formatting alert trees).
Return value: the number of the button clicked.

@{B}void windial_error(long error, char *message)@{b}

Opcode:        18
Function:      display an "error" alert box with a text appropriate
               for the `error' parameter value (e.g. when `error'
               is -2, the message will say "Resource busy"). The
               `error' value should be negative, exactly as
               returned by GEMDOS. These messages are provided by
               separate library called `kernel32.slb'.

               The second argument is optional and ignored when its
               value is -1. Otherwise it is treated as a pointer
               to a free string, which will be displayed in
               addition to the normal error message. The string
               should not be formatted as for an alertbox (the
               library does all necessary formatting) and should
               not exceed 40 characters in length. When it is
               necessary to split the message into two lines, you
               should use the "|" character for line break.

@line 1 70 0

@endnode

@node "Static library interface"
Static library interface
@line 1 70 0

This is a group of functions that directly interfaces the program
to the shared library, hence they are the corner stone of the
library bindings.

@{B}GEM_ARRAY *gem_control(void)@{b}

Opcode:       0
Function:     return a pointer to the application control array.
              The array is defined as follows:

              typedef struct {
                long  aesparams[6];
                short control[16];
                short global[16];
                short int_in[16];
                short int_out[16];
                long  addr_in[16];
                long  addr_out[16];
                long  vdiparams[5];
                short contrl[12];
                short intin[128];
                short ptsin[128];
                short intout[128];
                short ptsout[128];
                short vwk_handle;
                long  vwk_colors;
                long long vwk_xcolors;
              } GEM_ARRAY;

              The global[0] contains the AES version number encoded
              on four decimal digits: 0x0410 = 4.10. This number is
              internally used by the library to decide whether the
              appl_getinfo() call is available or not. It is
              assumed that if the AES version is below 4.0, the
              appl_getinfo() is not available (see Atari specs).

              The library is basically designed to work in a
              multitasking system and with AES version >= 4.0. It
              was not tested with old AESes.

              The field `vwk_handle' contains the current VDI
              handle for the virtual workstation open in a result
              of the appl_open() call. The `vwk_colors' field
              contains the number of colors displayable at one
              time. For > 24-bit per pixel displays this field will
              contain 16777216L, whereas the exact value will be
              indicated by the 64-bit field vwk_xcolors.

              Since this function makes GEMDOS calls, it has been
              separated from the call_aes() to reduce GEM call
              overhead.

Caveats:      The GEM_ARRAY structure contains more (undocumented)
              fields used internally by the library. These contain
              library internal data and are subject to change without
              notice.

Return value: a pointer to the application control array.


@{B}short call_aes(GEM_ARRAY *control, short function_number)@{b}

Opcode:       1
Function:     call an AES function. The `control' parameter is
              identical with the pointer returned by the
              gem_control() function above.
Caveats:      all AES calls the program does should be done via
              this function. Otherwise the library may not work
              correctly.
Return value: int_out[0] or ENOSYS, if the `function_number'
              parameter is out of the defined range.

@line 1 70 0

@endnode

@node "Application control functions"
Application control functions
@line 1 70 0

@{B}long appl_open(char *rscfile, short thread, char *pname)@{b}

Opcode:       17
Function:     First the application is switched into MiNT domain
              and registered in the AES with appl_init() call. When
              the parameter `thread' is zero, and the parameter
              `rscfile' is nonzero, it is treated as a pointer to a
              valid GEMDOS pathname of the GEM resource file to be
              loaded. When the parameter `thread' is nonzero, the
              `rscfile' pointer is ignored, and a previously loaded
              (by the parent process) resource file is utilized. It
              will only work, if the parent process has really
              loaded an RSC file via either appl_open() or
              rsrc_xload() call, and if the child shares the memory
              with him.

              If an error occurs while loading the RSC, the
              application registration gets cancelled by a call to
              appl_exit().

              The parameter `pname' is the application's name for
              the "Desk" menu. If this is -1, the parameter is
              ignored. If its value is below 65536, it is
              understood as a resource index of a free string in
              the resource file just loaded. Contrary, if it is
              greater than 65535, it is understood as an address of
              a free string which should be taken as the
              application's name.

              When the action above succeeds, the AES is
              additionally told the application recognizes the
              AP_TERM message and a basic VDI virtual workstation
              is open.

Return value: AES application ID on success, or a negative error
              code otherwise.

@{B}long appl_top(void)@{b}

Opcode:       25
Function:     Top the application, if possible.
Return value: 0 on success or a negative error code otherwise
              (currently this is ENOSYS standing for "invalid AES
              function call").

@{B}long appl_close(void)@{b}

Opcode:       39
Function:     Closes the virtual workstation that was open by
              appl_open(), releases the resource file (if loaded)
              by a call to rsrc_xfree() and leaves the GEM with
              appl_exit().
Return value: currently always 0 (success).

@line 1 70 0

@endnode

@node "Resource file related functions"
Resource file related functions
@line 1 70 0

@{B}long rsrc_xload(char *rscfile)@{b}

Opcode:       10
Function:     Cache the specified GEM resource file in the memory.
Caveats:      This is a custom library call, you cannot use
              rsrc_load() instead.
Return value: 0 on success or a negative error code otherwise.

@{B}long rsrc_xalloc(void)@{b}

Opcode:       11
Function:     Fixup the raw RSC file previously cached by the
              rsrc_xload() call.
Caveats:      This is a custom library call, you cannot use
              rsrc_rcfix() instead.
Return value: 0 on success or a negative error code otherwise.

@{B}long rsrc_xfree(void)@{b}

Opcode:       12
Function:     Release the RSC file previously loaded with
              appl_open() or rsrc_xalloc().
Caveats:      This is a custom library call, you cannot use
              rsrc_free() instead.
Return value: 0 on success or a negative error code otherwise.

@line 1 70 0

@endnode

@node "Environment functions"
Environment functions
@line 1 70 0

@{B}char *env_get(const char *variable)@{b}

Opcode:       21
Function:     Finds the specified variable in the application
              environment string. The variable name (pointed to by
              the argument) must be a NULL terminated string ended
              with the "=" character. For example, to find the
              value of the $HOME, the function call should look as
              follows:

                char *home;

                home = env_get("HOME=");

              The returned value specifies the variable litterally
              as it is defined in the environment, no conversion or
              evaluation is made.
Return value: a pointer to the variable value or NULL, if the
              specified variable does not exist.

@{B}char *env_eval(const char *variable)@{b}

Opcode:       22
Function:     This is similar to the env_get(), except that the
              variable, if found, is additionally processed as
              indicated by the $UNIXMODE variable.

              Furthermore, each variable is evaluated, so that a
              part of it (or an entire variable) can be defined by
              another one. For example, for a definition like:

                setenv HOME u:\root
                setenv MYDIR $HOME

              the $MYDIR will be evaluated and returned as
              `u:\root'. Similarly, if you define

                setenv HOME u:\root
                setenv MYDIR $HOME
                setenv DEFAULTS $MYDIR\defaults
                setenv CONFIGFILE $DEFAULTS\config.inf

              the env_eval("CONFIGFILE=") will return
              `u:\root\defaults\config.inf', whereas env_get()
              only returns `$DEFAULTS\config.inf' in this case.
Caveats:      - the recursion depth is limited to 64 levels.
              - the maximum recursion depth requires about 16k free
                stack space, and you should provide at least this
                much in case there is a circular reference between
                variables.
              - variables $PCONVERT and $UNIXMODE cannot be defined
                indirectly, because their values are used as
                arguments for the evaluation (references to other
                variables found in these two are ignored).
              - the variable $SLBPATH cannot be defined this way,
                because it is evaluated by the kernel and the code
                dealing with that is not so intelligent, for the
                sake of speed.
Return value: a pointer to the result string on success or NULL on
              failure.

@{B}long env_getargc(void)@{b}

Opcode:       23
Function:     returns the number of ARGV arguments. The old MS-DOS
              style command line is not supported.

@{B}char *env_getargv(long argc)@{b}

Opcode:       24
Function:     returns a pointer to the ARGV argument number `argc',
              or NULL, if there is no such argument. The old MS-DOS
              style command line is not supported.

@line 1 70 0

@endnode

@node "Windowed dialog management"
Windowed dialogs
@line 1 70 0

Routines for creating and managing windowed dialogs are the corner
stone of the library. In most cases, an application must only
provide memory for the WD structure which contains all the
information needed by the library to properly handle a window. The
structure is completely filled in and managed by the library so
that in most cases the programmer does not have to worry on the
sturcture's contents. The structure is defined by the source files
supplied along with the library.

@{B}long windial_size(void)@{b}

Opcode:       2
Function:     returns the minimum size of the WD structure for a
              single windowed dialog box. Your program should
              provide at least this much for each window it needs
              to create. It is guaranteed that the number returned
              by this function is the same for all dialog boxes the
              program needs to create - it only can be different
              across different versions of the lib.

              This function is only necessary, when you want to
              allocate all structures on your own. But you can let
              the library to automatically do that as well. See
              below.

@{B}long windial_create(WD *window, short box, short icon, \
                         short ftext, char *title)@{b}

Opcode:       3
Function:     initializes the window structure in the memory buffer
              pointed to by the `window' parameter. If the `window'
              is NULL, the function will first allocate the needed
              memory buffer (freed later by the windial_delete()
              function), though it is not an optimal choice.

              `box' is the resource index of the dialog box object
              tree. This parameter is obligatory.

              `icon' is the resource index of the icon object tree.
              If this parameter is 0, the dialog box won't have the
              iconifier gadget and no iconification will be
              possible.

              `ftext' is the resource index of the first editable
              textfield found in the object `box'. If there are no
              editable textfields in the box, the parameter should
              be 0.

              `title' is a pointer to a free string which will be
              used as the window's title displayed on its title
              bar. When no title is required, the pointer should
              point to an empty string (""), but also may be -1.
              When this parameter's value is below 65536, it is
              understood as a resource index of the RSC file loaded.

              Exactly like the AES function wind_create(), this one
              does not display any window. After a successful
              return, the structure WD initialized by the function
              can be manipulated so that the subsequent
              windial_open() call will display the window e.g. in
              an arbitrary location rather than the default one.

              Windows created by subsequent windial_create() calls
              are automatically linked to the list of caller's
              windows, so that no separate calls to windial_link()
              are normally necessary.

Return value: returns a pointer to the WD structure, or 0 if the
              function failed.

@{B}long windial_xcreate(WD *window, short box, short icon, \
                        short ftext, char *title, short gadgets)@{b}

Opcode:       3
Function:     Exactly like windial_create(), but the additional
              parameter defines window gadgets to be enabled.
Caveats:      This is just an alternative binding to the same
              function as for wind_create().

@{B}long windial_open(WD *window)@{b}

Opcode:       4
Function:     opens the windowed dialog box as defined by the
              parameter.
Return value: currently 0 (success).

@{B}long windial_formdo(WD *window)@{b}

Opcode:       5
Function:     similarly to the AES' form_do(), the function is
              monitoring the user interaction with the dialog box,
              or dialog boxes, if multiple are displayed at a time.
              Window events, like move, iconify, uniconify, full,
              top, untop etc. and also editable textfields, are
              handled automatically inside the library without
              arranging the main application.
Return value: the returned longword contains the resource index of
              the object clicked in the low word and the resource
              index of the object tree where the object belongs to
              in the high word. If the user clicked the closer
              gadget, a value of -1 is returned for the object
              index.
              When your program only displays one dialog at a time,
              the high word can be safely ignored.
Caveat:       if windial_setjmp() was used to define an alternative
              event handler, this function may never return.

@{B}long windial_close(WD *window)@{b}

Opcode:       6
Function:     closes the specified window. The window's structure
              in the memory is not released so that it can be
              reopened by windial_open().
Return value: currently 0 (success).

@{B}long windial_close_all()@{b}

Opcode:       44
Function:     closes all windows attached to the calling process.
              The window structures in the memory are not released
              so that any of the windows can be reopened by windial_open().
Return value: currently 0 (success).

@{B}long windial_delete(WD *window)@{b}

Opcode:       7
Function:     deletes the specified window. The window's structure
              in the memory is released so that it cannot be
              reopened by windial_open() without a previous call to
              windial_create().

              If the window is still visible on the screen upon calling
              this function, a call to windial_close() is made
              automatically.

Return value: currently 0 (success).

@{B}long windial_delete_all()@{b}

Opcode:       45
Function:     deletes all windows attached to the calling process.
              The window structures in the memory are released
              so that none of the windows can be reopened without
              a previous call to windial_create().

              Since this function is simply a series of functions
              windial_delete() called in a loop, it also calls
              windial_close() for any window, that is open
              during execution of the windial_delete_all().

Return value: currently 0 (success).


@{B}long windial_center(WD *window)@{b}

Opcode:       8
Function:     performs the window positioning at the centre of the
              screen.
Return value: currently 0.

@{B}long windial_link(WD *from, WD *to)@{b}

Opcode:       20
Function:     link the 'from' window to the linked list, a member
              of which is the 'to' window.

              NOTE:
              Windows created by subsequent windial_create() calls
              are automatically linked to the list of caller's
              windows, so that no separate calls to windial_link()
              are normally necessary.

Return value: 0 on success or a negative error code otherwise.

@{B}long windial_unlink(WD *window)@{b}

Opcode:       27
Function:     unlinks the specified window from the linked list
              created by windial_link(). The window's structure is
              simultaneously invalidated, so that it cannot be
              linked back. For this reason it is more advisable to
              use windial_delete(), which performs unlinking
              automatically.
Return value: currently 0. In case of an error the function
              silently fails.

@line 1 70 0

@endnode

@node "External event handlers"
External event handlers
@line 1 70 0

Here are functions which allow you to intercept and modify the
operation of the event handlers provided by the library.

@{B}long windial_setjmp(WD *window, short vec, void *adr)@{b}

Opcode:       26
Function:     registers an external handler for events which are
              not handled internally by the library. This is mainly
              intended for the AP_TERM and VA_START messages, but in fact
              any type of the standard GEM events can be intercepted this
              way. Each window can have own separate subset of such
              handlers (or can have none).
              The `vec' parameter contains the "vector number" for
              the required type of events. Currently these vectors
              are defined as follows:

              Vec       Handling
              ---       --------
               0        AES messages
               1        keyboard events
               2        mouse button events
               3        mouse rectangle events
               4        alternative mouse rectangle events
               5        timer events

              Of that number, handlers 0 to 2 are local for each
              window (i.e. each window can have different handler),
              whereas handlers 3-5 are global for all windows.
              The parameter `adr' is the new value of the vector
              `vec', i.e. the entry point for the new handler.

              The point defined by this argument *** MUST *** find
              itself in the same stack context as the initial call
              to the windial_setjmp() was, or else stack corruption
              may occur.

              The handler setup by this function is called before
              (if at all) the associated event is handled by the
              library routines, and accepts stacked arguments:

              Vec       Handler prototype
              ---       -----------------
               0        long newmsg(WD *wd, short vec, (void *)msg)
               1        long newkey(WD *wd, short vec, short ks, \
                                                        short kc)
               2        (not yet defined)
               3        (not yet defined)
               4        (not yet defined)
               5        long newtmr(WD *wd, short vec, long timer)

              Where `wd' is a pointer to the structure of the
              window, that generated the event (undefined for
              handlers 2-5), `vec' is the vector number, `msg' is
              a pointer to the AES message buffer, `ks' is a word
              containing the state of the keyboard shift keys, `kc'
              is the keycode and `timer' is the start value of the
              evnt_timer().

              The handler once entered and has done what was
              supposed necessary, may behave three ways. First, it
              can just return with a long value of 0 in the d0
              register, which means it wishes the event to be
              further processed by the library routines. In an
              opposite case, when no further processing is
              required, a long value of -1 should be returned.

              The keyboard handler has an additional function here:
              if the returned value is greater than a zero, it is
              interpreted as the new keycode. After return to the
              library, its routines do further processing using the
              code returned.

              Eventually, the windial_longjmp() may be called, which
              performs an exit from the event loop and jumps back
              here to return to the program exactly at the same
              point where the windial_setjmp() was originally
              called.

Return value: 0 on success or EINVAL when invalid argument was
              specified (particularly `vec' is out of range) while
              setting the jump. While returning from
              windial_longjmp() this function returns 1.

@{B}void windial_longjmp(WD *window, short vec)@{b}

Opcode:       28
Function:     returns from the event handler (see above), restores
              the stack context to the state recorded by the
              windial_setjmp() call, then jumps back to the
              windial_setjmp() function.
              The function of this call is similar to the operation
              made by the sigreturn() and longjmp() when returning
              from kernel signal handlers.
Return value: this function never returns.

@line 1 70 0

@endnode

@node "Library functions listed by opcode"
Library functions listed by opcode
@line 1 70 0

Opcode          Function prototype
------          ------------------
  0             GEM_ARRAY *gem_control(void)
  1             long call_aes(GEM_ARRAY *ctrl, short opcode)
  2             long windial_size(void)
  3             long windial_create(WD *window, short box, short icon, \
                                    short ftext, char *title)
  4             long windial_open(WD *window)
  5             long windial_formdo(WD *window)
  6             long windial_close(WD *window)
  7             long windial_delete(WD *window)
  8             long windial_center(WD *window)
  9             long rc_intersect(GRECT *src, GRECT *dest)
  10            long rsrc_xload(char *filename)
  11            long rsrc_xalloc(void)
  12            long rsrc_xfree(void)
  13            long thread_fork(void *stub, void *func, char *ptitle, \
                                 long stksize)
  14            long windial_alert(short button, char *string)
  15            long objc_xchange(WD *window, short obj, short newst, \
                                    short redraw)
  16            void *rsrc_xgaddr(short type, short object)
  17            long appl_open(char *filename, short thread, char *pname)
  18            long windial_error(long error, char *usermsg)

  19            (reserved)

  20            long windial_link(WD *from, WD *to)
  21            char *env_get(char *var)
  22            char *env_eval(char *var)
  23            long env_getargc(void)
  24            char *env_getargv(short argc)
  25            long appl_top(void)
  26            long windial_setjmp(WD *window, short vec, void *adr, \
                                        void *link)
  27            long windial_unlink(WD *window)
  28            void windial_longjmp(WD *window, short vec)
  29            void ftext_init(short tree, short obj)
  30            long av_dir_update(short drive)
  31            long av_view(char *pathname)
  32            long av_help(char *filename)
  33            long va_send(short cmd, char *msg, long len)
  34            long lib_control(short fn, long value)
  35            long objc_xdraw(WD *window, short object)
  36            long thread_overlay(void *stub, void *func, \
                                        char *ptitle, long stksize)
  37            long menu_xpop(WD *window, short obj, MENU *menu)
  38            char *file_select(char *title, short flag)
  39            long appl_close(void)
  40            long open_url(char *url)
  41            long proc_exec(short mode, long flags, \
                                char *file, char *cmd, char *env)
  42            char *get_version(void)
  43            long get_users(void)
  44            long windial_close_all(void)
  45            long windial_delete_all(void)

@line 1 70 0

@endnode

@node "Accompanied libraries"
Accompanied libraries
@line 1 70 0

a) kernel.slb

   This library is loaded when it is necessary to convert a GEMDOS
   error code to appropriate error message. It is done
   automatically inside the windial_error() function. The
   kernel.slb is supplied along with the gemma.slb in one
   distribution.

b) fileselector.slb

   This library is not supplied, at least for now. An attempt is
   made to open it on every call to fsel_exinput(), prior to
   calling the AES. When opening is successful, the function 0 of
   the fileselector.slb is supplied with the pointer to the
   GEM_ARRAY structure filled with parameters necessary for doing
   fsel_exinput(). It is exspected that the function will display
   the fileselector and the returned code is equivalent to the
   result of fsel_exinput(), and it is passed back to the calling
   application.

   The prototype of the function called (no. 0) is:

   long fsel(BASEPAGE *bp, long fn, short nargs, \
                GEM_ARRAY *gem, SLB *gemma, ulong bvset)

   The `gemma' argument is a pointer to the SLB structure for the
   gemma.slb library. Thus, the function fsel() can call-back gemma's
   functions without re-opening it or employing different bindings.

   The `bvset' argument is a bitmap of mounted drives to be used by
   the fileselector window. By default it is initialized to the
   value returned normally by the Dsetdrv(Dgetdrv()), i.e. to the
   bitmap of all mounted drives known by the system.

   NOTICE
   Because of some modifications necessary in the static part of
   appl_open(), such indirect usage of fileselector.slb is only possible
   for programs compiled for Gemma lib version equal or newer than 1.09.

@line 1 70 0

@endnode

@node "Emulation"
Emulation
@line 1 70 0

Several functions are emulated when not supported by host AES. The
emulation strongly depends on proper configuration of the gemma.slb. To
work properly, the shared object must be configured properly at compile
time (see config.h) and at runtime (see config.app). The library contains
code that emulates or semi-emulates the following functions:

a) fsel_exinput()

On AES versions below 1.40 (TOS 1.04) all references to fsel_exinput() are
redirected to fsel_input(), unless usage of fileselector.slb was
specified.

b) form_popup()

On AES versions which don't support form_popup(), the call is emulated
using menu_popup() call (available on AES 3.30 and newer).

c) scrp_clear()
d) appl_yield()

It is emulated on all AES versions.

e) appl_getinfo()

It is emulated on AES versions below 4.0.

f) appl_bvset()

The values passed are recorded (on per process basis) and passed as
an argument to the fileselector.slb, when ones is used.

g) menu_unregister()
h) menu_click()

It is ignored and a value of 0 is returned.

i) graf_multirubber()
j) wind_draw()

It is supported by N.AES.

k) wind_new()

It is supported by AES versions equal to 1.40 and up. In older
AESes it is ignored and a value of 0 is returned.

@line 1 70 0

@endnode

@node "CHANGES"
CHANGES
@line 1 70 0

TODO:

- code the nonmodal alerts
- add font selection support
- support the xrsrc
- emulate drawing WHITEBAK objects where not directly supported

Version 1.11

- added two new functions: opcode 44 windial_close_all() and
  opcode 45 windial_delete_all().
- if the user hasn't registered a message handler for AP_TERM,
  the message is now handled automatically inside the windial_formdo()
  by calling windial_delete_all(), appl_close() and Pterm().
- and the same is done for Control/Q.
- libgemma.a reworked to provide MT support.

Version 1.10

- various changes applied to compile without -mshort
- appl_open() now checks, whether the fileselector.slb is present
  before loading it. When the slb is not found, its flag gets
  unchecked.
- restructurizing of the local includes; fixed most compile time
  warnings at the occasion.
- wind_close() now only draws zoom/moveboxes for non-iconified
  windows.
- libgemma.a now defines struct for the kernel32.slb library and
  automatically assigns it a value - no need to separately define
  it inside the program.

Version 1.09 pl 2

- windial_create() now automatically links subsequently created
  windows in one chain, when at least one exists.
- windial_link() returns 0, not `newhandle'
- some DOS functions redirected to kernel.slb
- appl_open(), when fails, now closes the kernel.slb
- appl_close() doesn't check if kernel.slb is loaded before closing
  it (because kernel.slb is always exspected to be loaded)
- improved trap #2 interface.
- minor changes in the config tool program.
- most of the code for proc_exec() now uses kernel.slb (this makes
  gemma.slb smaller).
- function prototypes made as static inline functions for gcc.

Version 1.09 pl 1

- argh, multiple dialog boxes weren't handled correctly, when moved
  etc., hopefully fixed now.
- a window may be now opened, and also closed, only once.
- the first automatically allocated window (which in fact has
  its static buffer in the process array structure) cannot be now
  unlinked from the window chain.
- when windial_delete() is called for a window, which is still
  visible on the screen, windial_close() is first called
  automatically.
- objc_xchange() shouldn't now redraw objects inside closed windows.

Version 1.09

- multidialog support added.
- added built-in routines emitting debug information.
- the debug info can be now separately enabled at runtime
  by any process and only related information will be put out.
- the debug facility can be also globally disabled so that programs
  couldn't enable it.
- fixed a bug in windial_alert(), which caused to search the RSC
  file always for the string number 0.
- fixed a flaw in the documentation related to windial_alert().
- resorted the format of internal control field.
- added configuration program.
- while calling fsel_exinput() the library now can first try to
  pass the control to external library named `fileselector.slb'.
- external library error.slb now dropped in favour of more useful
  kernel.slb.
- function windial_dup() removed.
- added recognition of WHITEBAK keyboard shortcuts.
- fixed two minor bugs in windial_create(): the maximum object
  index in an RSC is 0xfffe, not 0xffff.
- removed unused modules errlist.c (moved to kernel.slb) and
  version.c (moved to misc.c)
- the switch _HAVE_FSEL_EXINPUT is now undefined by default.
- removed modules sflags.c and ctrl_list.c (both moved to callout.c)
- av_dir_update() now accepts -1 as argument, meaning `all drives'.
  It will also work when no AV server is present (under AES 4.0 and
  up).
- the static modules (libgemma.a) can now fill the control[] array
  with arbitrary values, when necessary.
- added emulation of scrp_clear() call.
- completed static bindings for libgemma.a
- menu compensation now correctly uses the height of the system
  font (returned by graf_handle()) to make assumptions on the
  height of the menu bar.
- the values passed by the appl_bvset() call is now passed to the
  fileselector.slb, when that last is used.
- the kernel.slb and fileselector.slb are now loaded inside
  appl_open()
- access test is now done also in the extended mode of shel_write().
- the static code for appl_open() now provides the pointer to the gemma
  SLB structure to the library itself. Thus library functions can pass
  this pointer to other libraries, so that these libs can call back
  gemma.slb to use its functions without re-opening it.
- added a flag to callout.c which indicates, whether a call to
  fsel_exinput() came directly from a process, or perhaps it is a
  call-back from previously invoked fileselector.slb. This allows
  to avoid an obvious deadlock, when the fileselector.slb calls the
  function it replaces.

Version 1.08 pl 3

- removed the internal list of system errors and converted into a
  separate library `error.slb', which is loaded when necessary.
- appl_open() now first searches $HOME directory for the RSC file.
- bit 2 of the flag parameter to appl_open() now added
- fixed a bug that made loading extended RSC files impossible
- added some debug blurp here and there
- added pathname conversion to the internal DOS functions

Version 1.08 pl 2

- fixed bug in objc_xchange()
- fixed possible inconsistency in the users count
- reduced number of casts, passim (a NULL pointer is also a pointer)
- new icons for alert boxes are available as of AES 4.10, not 4.0
- added a pointer to the begin of the window chain to the internal
  application structure
- minor bugfixes
- zeroing the `icon' parameter for windial_create() didn't disable
  the iconifier gadget, fixed now.

Version 1.08 pl 1

- appl_open() now changes the mouse shape to arrow.
- added appl_getinfo() emulation done so that the function can be
  safely called on AES < 4.0 as well. Especially the emulation
  indicates features introduced to the AES 3.30 and 3.31 (Falcon
  TOS has AES 3.40).
- fsel_exinput() may be called on AES < 1.40 (fsel_input() is
  invoked)
- added appl_yield() emulation.
- added function number 36, thread_overlay().
- fixed all (?) bugs in proc_exec()
- env_getargc() and env_getargv() implemented.
- internal AES calls redirected through emulation code in callout.c
  (new file). Calls to graf_growbox() etc. can be filtered out
  before reaching the AES, there is pointer verification etc.
- the objc_xdraw() converted to a macro and moved into the lib as
  function number 35.
- added config.h file containing compile-time options.
- added form_popup() emulation.
- corrected some typos here and there

Version 1.07

- added function number 41, proc_exec()
- env variable names for open_url() changed to avoid conflicts with
  text based, or other gui based applications.

Version 1.06

- the entire library has been rewritten in C and compiled with
  gcc 2.95.2.
- all functions have been extended with an additional parameter.
  The application can now maintain the pointer to its GEM_ARRAY and
  pass it to the library along with other function parameters. This
  allows to greatly reduce the function call overhead inside the
  library.
  This extension is compatible with previous versions of the
  library. Programs compiled for the last assembler version of the
  gemma.slb (i.e. 1.04) should still work.
- internal reorganization and revision for all of the code allowed
  to reduce function overhead, memory requirements, and also to do
  many bugfixes here and there.
- windial_alert() now accepts char * as the second parameter. This
  extension is compatible with previous versions of the library:
  when no third parameter is passed, the old calling style is
  assumed and the arguments are adjusted appropriately.
- all functions now return EACCES when no appl_init() was called
  before.
- removed redundant code in windial_center()
- the WINDIAL structure (one copy) is now integrated into the
  internal application structure maintained by the library and
  automatically assigned to the first windowed dialog the program
  creates without assigning it a predefined memory block. This
  saves some memory in case of programs which display only one
  window.
- the `mask' parameter for file_select() is no longer ignored,
  neither is `flag'.
- bugfixes in initialization of the object tree for screen modes
  with less than 16 colours (should be recursive though)
- fixed bug in av_dir_update(), the AES version number instead of
  the sender apid was sent to the AV server :>
- operations on window objects, when it is iconified, should work
  now.
- added functions: va_send(), get_users(), get_version().

Version 1.05 is skipped

Version 1.04

- editable text fields can be now activated with a mouse click
- windial_create() now automatically initializes editable text
  fields starting from the object given as the first field.
- call_aes() expanded to recognize N.AES calls objc_xfind(),
  graf_multirubber(), form_popup().
- windial_create() now recognizes additional parameter defining
  gadgets. The alternative binding for C is named windial_xcreate().
- call_aes() now recognizes MagiC wdlg_*() calls (but they aren't
  emulated).

1.XI.2000.

- rsrc_xgaddr() now goes through the common calling sequence, and
  all internal calls to rsrc_gaddr() go through rsrc_xgaddr().
- memory page size is now read from the system, if this is
  impossible, 8k is assumed.
- rsrc_xalloc() now checks whether the functions it uses are
  present and supported by the AES.
- some functions verify input addresses before calling the AES.
  This is to prevent the AES from bombing down when an invalid
  address is specified. Since the verification is done by touching
  the address, the faulty process will die, but the system will
  survive.
- fixed a bug that made programs crash when rsrc_rcfix() was not
  present, the library clients now less or more work under XaAES.
- windial_error() was full of nasty bugs and I am surprised it
  worked at all.
- introduced vertical positioning compensation, depending on a flag
  in the header.

Version 1.03

- fixed bad bug related to iconification
- included VDI support, appl_open() now opens the VDI
- appl_close() function added.
- appl_open() now does menu_register()
- functions preserve all registers, this solves problems with gcc
  programs.
- appl_open(), windial_create() and windial_error() now
  automatically convert RSC indexes into addresses for free strings
  given as parameters.
- made windial_setjmp() & windial_longjmp() calls
- added fileselector support
- more bugfixes
- appl_open() returns all errors to the caller again
- fixed wrong definition of the call_aes() in gemma.h
- fixed a bug in the event handler that caused the library to loss
  keystrokes sometimes.

Version 1.02

- added functions ftext_init(), av_dir_update(), av_view(),
  av_help(), open_url()
- redefined the order and number of the stacked arguments passed to
  the external event handlers (this breaks compatibility with
  previous versions).
- added handling external handler vector 5 (evnt_timer)
- memory allocations done by the library are now under the scope of
  a semaphore (the same one as in thread_fork())
- removed separator conversions in paths, this is not required by
  MiNT and not necessary on other systems.
- appl_open() now switches into MiNT domain and registers AP_TERM
  message in the system.
- added StringServer support.
- appl_open() now displays a message and terminates the program, if
  appl_init() fails.
- removed an unused buffer

Version 1.01

- various tests and bugfixes

Version 1.00

- initial version, quite buggy and limited.

@line 1 70 0

@endnode
